Программное средство «Обработчик сетевых взаимодействий» (ISEMS-NIH).
Описание. Функциональные возможности.

Пояснение

	В документации  используется термин «источник», то есть территориально удаленный физический сервер с установленным специальным программным обеспечением применяемым для выполнения некоторых, заранее определенных программным интерфейсом, команд и передаче специализированной технической информации.

Введение

	Программное средство «Обработчик сетевых взаимодействий» (далее — ПО ISEMS-NIH) предназначено для формирования, выполнения и учета задач по фильтрации сетевого трафика на одном или более удаленных источников.  Кроме того ПО ISEMS-NIH реализует загрузку, полученных в результате фильтрации файлов, в автоматизированном или ручном режиме и обеспечивает их учет и долговременное хранение на локальном файловом хранилище.
	ПО ISEMS-NIH является набором из двух программных модулей, модуль ISEMS-NIH-master и модуль ISEMS-NIH-slave. Модуль ISEMS-NIH-master является центром удаленного управления произвольным набором «источников», на которых установлены модули  ISEMS-NIH-slave.  Модуль ISEMS-NIH-master отдает команду ISEMS-NIH-slave на выполнение задачи (например, задача по фильтрации сетевого трафика), ведет контроль и учет процесса её выполнения, а также может оказать непосредственное влияние на неё, например, остановив выполнение задачи.  Модули ISEMS-NIH-master и ISEMS-NIH-slave позволяют строить распределенную архитектуру типа многих-ко-многим. Проще говоря, модуль ISEMS-NIH-master №1 позволяет осуществлять соединение и управление со многими модулями ISEMS-NIH-slave №СА_1-СА_N, а модуль ISEMS-NIH-master №2 позволяет осуществлять соединение и управление со многими модулями ISEMS-NIH-slave №СБ_1-СБ_N. Однако ничто не мешает, при наличии должных настроек и идентификационного токена, модулю   ISEMS-NIH-master №МБ_1 осуществлять контроль и управление одного или более модулей  ISEMS-NIH-slave №СБ_N. При этом модуль ISEMS-NIH-slave четко понимает с какого модуля ISEMS-NIH-master была прислана задача и взаимодействует по выполнению этой задачи только с данным модулем.
	Осуществление сетевого подключения между модулями  ISEMS-NIH-master и  ISEMS-NIH-slave основано на клиент серверной архитектуре. При этом кто из модулей  ISEMS-NIH-master и  ISEMS-NIH-slave будет являться клиентом, а кто сервером целиком зависит от конфигурационных настроек модулей. Модуль ISEMS-NIH-master одновременно выступает как клиент и как сервер. Он слушает, на заданном в конфигурационном файле, сетевом порту запросы на соединения от модулей  ISEMS-NIH-slave, сконфигурированных как клиент и сам пытается установить соединение с модулями  ISEMS-NIH-slave сконфигурированными как сервер. Модуль  ISEMS-NIH-slave, в зависимости от конфигурации, может выступать или как клиент или как сервер. В режиме клиент, модуль будет пытаться установить сетевое соединение с ISEMS-NIH-master, а в режиме сервер будет сам выступать в роле сервера открыв доступный для соединения сетевой порт. Все сетевое взаимодействие между модулями  ISEMS-NIH-master и  ISEMS-NIH-slave осуществляется по криптографически защищенному (протокол TLSv1.2) каналу связи, аутентификация сетевого соединения осуществляется по средствам передачи идентификационного токена. Кроме того, сетевые соединения приходящие с неизвестных ip адресов, даже с правильным токеном, модулями не обслуживаются.

	
Модуль  ISEMS-NIH-slave

	Основным режимом работы для модуля ISEMS-NIH-slave является режим, при котором управление и контроль выполняемых задач осуществляется с модуля ISEMS-NIH-master. При этом, предполагается что, модуль ISEMS-NIH-master территориально удален от ISEMS-NIH-slave, а все взаимодействие между ними осуществляется по сети Internet. Однако это не обязательно, модуль ISEMS-NIH-master может устанавливаться на тот же сервер что и ISEMS-NIH-slave, а все сетевые взаимодействие между, ними будут организованы через localhost, но это потребует дополнительного программного обеспечения. Кроме этого, модуль ISEMS-NIH-slave предоставляет API для взаимодействие с ним через Unix сокеты, хотя это и  уменьшает количество видов выполняемых им задач. Модуль  ISEMS-NIH-slave позволяет устанавливать и обеспечивать сетевое взаимодействие с одним и более ISEMS-NIH-master и одновременно осуществлять взаимодействие со одним и более сторонним программным продуктом по средствам Unix сокетов. Для активации Unix-socket сервера в конфигурационном файле config.json модуля ISEMS-NIH-slave нужно изменить значение параметра «forLocalUse» c «false» на «true», также есть раздел «toConnectUnixSocket» ответственный за настройку Unix сокетов, где в параметрах «socketName» задается имя Unix сокета (он создается в стандартной директории tmp), а в параметре «token» идентификационный токен.
	Соединение через Unix сокет начинается с передачи «Ping» сообщения вида:
{
	'token': <идентификационный_токен>,
	'clientID': <идентификатор_клиента>,
	'messageType': <ping>, //для Ping это «ping» фильтрации это «filtration»
	'info': {
		'enableTelemetry': <bool>,
		'typeAreaNetwork': <ip или  pppoe>,
		'storageFolders': <массив директорий с файлами для фильтрации> 
	}
}
	Сообщение типа «Ping» устанавливает такие локальные настройки для модуля ISEMS-NIH-slave как, нужна ли передача телеметрии («enableTelemetry»), какой тип фильтра применять для обработки сетевого трафика («typeAreaNetwork»), а также в каких директориях хранятся файлы для фильтрации («storageFolders»). При этом, если «enableTelemetry» и «typeAreaNetwork» устанавливать не обязательно, будут взяты параметры по умолчанию «false» и «ip» соответственно, то «storageFolders» необходимо установить, так как в противном случае не будет работать фильтрация.
 	Строго говоря, сообщение типа «Ping» не всегда обязательно, например, если при взаимодействии через Unix сокет с  модулем ISEMS-NIH-slave уже было установлено   сетевое соединение, то параметры «typeAreaNetwork» и «storageFolders» переданные в сообщении «Ping» более не учитываются (до тех пор пока не будут разорваны все сетевые соединения и соединения по Unix сокету, а потом установлено новое соединение по сети или через Unix сокет).
	Для запуска, через Unix сокет, задачи по фильтрации передается сообщение вида:
{
	'token': <идентификационный_токен>,
	'clientID': <идентификатор_клиента>,
	'messageType': <ping>, //для Ping это «ping» фильтрации это «filtration»
	'info': {
		'id': <id_задачи>
		'c': <команда> // для фильтрации это 'start', 'stop'
		'o' : { //опции фильтрации
			'dt': {
				's': <start_unix_timestamp>
				'e': <end_unix_timestamp>
			},
			'p': <транспортный_протокол> //udp, tcp 
			'f': {
				'ip': {
					'any': []
					'src': [] 
					'dst': []
				},
				'pt': {
					'any': []
					'src': [] 
					'dst': []
				},
				'nw': {
					'any': []
					'src': [] 
					'dst': []
				}
			}
		}
	}
}

	По мере выполнения задачи будут генерироваться информационные сообщения вида: 
{
	'messageType': <тип> // для фильтрации это filtration
	'info': {
		'tid': <уникальный идентификатор задачи>
		'ts': <статус_задачи> //"execute" — выполняется, "complete" - завершена
		'nfmfp': <всего файлов_которые_необходимо_отфильтровать>
		'npf': <обработанных_файлов>
		'nffrf': <найдено_файлов_удовлетворяющих_параметрам_фильтрации>
		'ndf': <кол-во_директорий_по_которым выполняется_фильтрация>
		'nepf': <файлов_обработанных_с_ошибкой>
		'sfmfp': <общий_размер_файлов_которые_необходимо_обработать> //в байтах
		'sffrf': <общий_размер_найденных_файлов> //в байтах
		'pss': <директория_для_хранения_найденных_файлов> // на ISEMS-NIH-slave
		'nmp':[0,0] // заполняется только при статусе задачи "complete" и только при сегментации сообщения
		'ffi': { //заполняется только если файл найден
			<имя_файла> :{
				's': <размер_найденного_файла> // в байт
				'h': <контрольная сумма файла> // в MD5
			}
		}
	}
}
	Управление фильтрацией сетевого трафика. При этом информационные сообщения о ходе выполняемой задаче будут отправляться только тому приложению, которое дало команду на ее выполнение. Так как через Unix сокет с модулем ISEMS-NIH-slave одновременно, может взаимодействовать несколько сторонних программных продуктов.

Модуль  ISEMS-NIH-master

	Для взаимодействия со сторонними программными продуктами в модуле ISEMS-NIH-master реализован прикладной программный интерфейс (Application Programing Interface — API) (далее — сервер API). Все взаимодействие со сторонним приложением (далее — клиент API) осуществляется через постоянное, криптографически защищенное (протокол TLSv1.2) сетевое соединение с использованием протокола передачи данных Websocket. Фактически получается security websocket туннель. Для инициализации соединения клиент API должен передать серверу API свой идентификационный токен на основе которого происходит аутентификация и авторизация клиента API. При успешной аутентификации и авторизации клиента API сервер API запрашивает актуальный список источников отправляя запрос в формате JSON вида:
{
	t: 'command', // type - тип сообщения (командное/информационное)
	s: 'source control', // section - секция ('source control'/'filtration control'/'download control'/'information search control')
	i: 'get new source list', // instruction - инструкция ('get new source list'/'change status source' и т.д.)
	o: {	} // options - дополнительные опции
}
здесь и далее весь обмен информацией между клиентом API и сервером API осуществляется в формате JSON сообщений.

Функциональные возможности.

1. Управление источниками

- Обработка полученного от клиента API актуального, для этого клиента, списка источников и сохранения его в базе данных сервера API. На основе информации из этого списка приложение будет осуществлять подключение источников, их  аутентификацию и управление определенными функциями источников. Таким образом полученное сообщение должно иметь определенную структуру и содержать некоторые технические параметры. Пример сообщения:
{
	t: 'information',
	s: 'source control',
	i: 'send new source list',
	o: {
		sl: [ 
			{
			id: <INT> // ID - уникальный цифровой идентификатор источника
			at: 'none',
			arg: { // argument — дополнительные аргументы
				ip: <STRING> //ip адрес	
				t: <STRING> //token - уникальный строковый токен для аутентификации
				sn: <STRING> //shortName — краткое название источника
				d: <STRING> //description — полное название источника
				s: { //settings — параметры
					as: <BOOL> // asServer
					p: <INT> // port — порт если asServer true
					et: <BOOL> // enableTelemetry — правление телеметрией true/false
					mcpf: <INT> // maxCountProcessFiltration - число 1-10, максимальное количество одновременно запущенных процессов фильтрации
					sf: [ARRAY] // storageFolders - список директорий с файлами сет. трафика
					tan: [STRING] // typeAreaNetwork — тип протокола канального уровня ('ip' или 'pppoe')
					}
				}
			}
		]
	}
}  

- Реализована возможность подключения к серверу API одного и более количества клиентов API, при этом от каждого клиента API может быть получен свой список источников. По запросу типа:
{
	t: 'command',
	s: 'source control',
	i: 'get an updated list of sources'
	tid: <уникальный идентификатор задачи>
	o: {}
}
любой клиент API может получить полный список источников находящийся в распоряжении сервера API и осуществлять некоторые действия (фильтрация, выгрузка файлов и с некоторыми ограничениями управление источниками) над источниками которые ему не принадлежат. Из-за ограничений политики безопасности клиенту API передается «урезанный» список источников в котором отсутствуют некоторые параметры, в том числе уникальный идентификационный токен источника. Пример JSON сообщения:
{
	t: 'information',
	s: 'source control',
	i: 'send current source list',
	o: {
		ti: { // taskInfo — информация по задаче 
			s: <STRING> // state — состояние выполнения задачи, 'ready'/'executed'/'executed completed'/'completed'/'stop'/'removed' ('готова'/'выполняется'/'завершена частично'/'завершена полностью'/'остановлена'/'снята из-за тех. cбоя')
			e: <STRING> // explanation — описание состояния, при необходимости
		},
		sl: [ ARRAY
			{
				id: <INT> //id - уникальный цифровой идентификатор источника>
				ip: <STRING>, // ip адрес
				sn: <STRING>, // shortName — краткое название источника
				d: <STRING> //discription — описание источника
			}
		]
	}
}
- При выполнении определенных действий и в ответ на команды получаемые от клиента API данному клиенту могут приходить информационные сообщения вида:
{
	t: 'information',
	s: 'user notification',
	i: 'send notification',
	tid: <уникальный идентификатор задачи>
	o: {
		n: { //notification — сообщение клиенту
			t: <STRING> //type - тип сообщения, 'info'/'success'/'warning'/'danger'
			d: <STRING>, //description — описание сообщения
			s: [ARRAY] //sources - перечень источников к которым применимо данное сообщение		
		}
	}
}

при этом все информационные сообщения имеют четыре статуса критичности: информационный (info), подтверждение успешного выполнения (success), требующий обратить внимание (warning) и информирование о невозможности выполнения действия (danger). Так же сообщение содержит исчерпывающее описание проблемы или выполненного действия на русском языке которое можно выводить в GUI.

- Клиент API может управлять одним или более источником, выполняя следующие действия: добавить, удалить, изменить параметры источника, выполнить переподключение источника, сделать запрос на получения статуса источника (подключен/неподключен).
	Добавление источника возможно только если уникальный цифровой идентификатор источника не совпадает с идентификаторами в базе данных модуля ISEMS-NIH. Если совпадение будет найдено клиент API получит соответствующее  информационное сообщение. 
	Удаление или изменение параметров источника возможно только если на источнике не выполняются задачи по фильтрации или выгрузке файлов, кроме того подобные действия разрешены только клиенту API которому «принадлежит» данный источник, то есть клиенту API который ранее добавил этот источник через команду «добавить» или передал информацию по источнику в списке при подключении.
	Выполнить переподключение источника может любой клиент API но только в том случае если на источнике в данное время не выполняется задача по выгрузке файлов и если источник в настоящее время подключен.
	Запросить и получить статус источника, состояние его подключения, может любой клиент API.
	Задание на выполнение выше перечисленных действий может относится как к одному источнику так и к группе источников. В одном JSON сообщении может быть скомбинированы задачи по добавлении источников с id 100 и 101, удалении источника с id 120, изменении параметров подключения источников с id 113 и 115, переподключении источников с id 100, 115, 141, 152 и запрос состояний источников с id 117 и 118. При этом если запрос на переподключение источника с id 100 будет обработан раньше чем этот источник будет добавлен и с ним установится соединение переподключение выполнено не будет, а в информационном сообщении для данного источника будет значится что источник с заданным id в списках отсутствует. Пример JSON сообщения на выполнение действий:
{
	t: 'command',
	s: 'source control',
	i: 'performing an action'
	tid: <уникальный идентификатор задачи>
	o: {
		sl: [
			{
			id: 1001,
			at: 'add', 
			arg: {
				ip: '134.67.23.14',
				t: 'ff83yh88y447gf7g77g37gd7g37d3d3',
				sn: 'Mid RF'
				d: 'Министерство иностранных дел Российской Федерации'
				s: {
					as: false
					p: 0
					et: flase,
					mcpf: 3,
					sf: ['/_TRAFFDIR_1', '/_TRAFFDIR_2','/_TRAFFDIR_3'],
					tan: 'ip' 
					}				
			},
			{
			id: 1002,
			at: 'update', 
			arg: {
				ip: '45.22.100.6',
				t: '9u388rhf838rhh84tt99t59588gh58849',
				sn: 'CIK RF'
				d: 'Центральная избирательная комиссия Российской Федерации'
				s: {
					as: true
					p: 13000
					et: flase,
					mcpf: 4,
					sf: ['/_TRAFF_DIR_1', '/_TRAFF_DIR_2','/_TRAFF_DIR_3'],
					tan: 'pppoe'
					}				
			},
			{
			id: 1015,
			at: 'delete', 
			arg: {},
			{
			id: 1073,
			at: 'delete', 
			arg: {}
			},
			{	
			id: 1042,
			at: 'reconnect', 
			arg: {}
			},
		],
	}
}
Пример JSON сообщения о выполненных действиях:
{
	t: 'information',
	s: 'source control',
	i: 'confirm the action',
	tid: <STRING> // taskID — уникальный идентификатор задачи
	o: {
		ti: {  
			s: 'end'
			e: <explanation — описание состояния, при необходимости>
		},
		sl: [
			{
				id: 1002
				s: 'connect',
				at: 'update'
				is: isSuccess — успешность (true/flase)
				mf: <STRING> //  messageFailure — сообщение об ошибке
			},
			{
				id: 1001
				s: 'disconnect',
				at: 'add'
				is: true
				mf: ''
			}
		]
	}
}
- Сервер API автоматически информирует всех подключенных к нему клиентов API об изменении статуса состояния источника (с подключен на не подключен или наоборот).
Пример JSON сообщения об изменении статуса источников:
{
	t: 'information',
	s: 'source control',
	i: 'change status source',
	o: {
		sl: [ ARRAY //sourceList - список источников
			{ 
				id: <INT> // ID - уникальный цифровой идентификатор источника
				s: 'connect'/'disconnect'
				at: 'none'
				is: 'true'
				mf: ''
			}		
		]
	}
}

- Сервер API автоматически принимает телеметрию со всех подключенных к Серверу API источников в настройках которых данная опция включена и рассылает информацию о телеметрии всем клиентам API.
Пример JSON сообщения телеметрии:
{
	t: 'information',
	s: 'source control',
	i: 'send telemetry',
	o: {
		id: <INT> //id - уникальный цифровой идентификатор источника>
		i: { 
		currentDateTime: 1554819847000,
  		diskSpace: [ [Object], [Object], [Object] ],
  		timeInterval:{
			'/_TRAFDIR_1221_1': [Object],
  			'/_TRAFDIR_1221_2': [Object],
  			'/_TRAFDIR_1221_3': [Object],
  			'/_TRAFDIR_1221_4': [Object] },
  		randomAccessMemory: { total: 32947612, used: 24583640, free: 8363972 },
  		loadCPU: 4.46,
  		loadNetwork:{ eth0: [Object], eth1: [Object], eth2: [Object], eth3: [Object] } } }
		}
	}
}

2. Управление фильтрацией сетевого трафика

	Задачи по фильтрации сетевого трафика могут осуществляться одновременно на одном или более источниках, при этом количество одновременно выполняемых процессов фильтрации на одном источнике должно быть не больше «N». Где «N» - это значение  «mcpf» (max count process filtration), равное диапазону значений 1-10. При превышении максимального количества задач фильтрации задача будет отклонена, а клиенту API будет возвращено соответствующее информационное сообщение.
	Параметры фильтрации сетевого трафика задаются клиентом API, при этом для фильтрации используются следующие параметры: 
- обязательные, начальное и конечное дата и время, в формате Unix (в секундах);
- не обязательные, тип протокола сетевого взаимодействия;
- должен присутствовать хотя бы один из параметров:
	1. ip адрес не зависимо от направления, один или более (addr);
	2. ip адрес источника, один или более (src);
	3. ip адрес назначения, один или более (dst);
	4. сетевой порт не зависимо от направления, один или более (addr);
	5. сетевой порт источника, один или более (src);
	6. сетевой порт назначения, один или более (dst);
	7. сеть с маской подсети не зависимо от направления, один или более (addr);
	8. сеть с маской подсети источника, один или более (src);
	9. сеть с маской подсети назначения, один или более (dst).

	При этом логика при обработке параметров запроса при фильтрации следующая:
- начальная дата и время «И» конечное дата и время «И» тип протокола сетевого взаимодействия «И» основной набор фильтров по поиску ip адресов, портов, подсетей;
- (поиск ip адресов «ИЛИ» подсетей) «И» сетевых портов;
- ip адреса, порты или подсети. Внутри addr, src, dst применяется условие «ИЛИ», например, <порт_1> «ИЛИ» <порт_2> «ИЛИ» <порт_3>. Между addr, src, dst используется addr «ИЛИ» (src «И» dst).
	Пример запроса отправляемого клиентом API для выполнения задачи по фильтрации сетевого трафика:
{
	t: 'command',
	s: 'filtration control',
	i: 'to start filtering',
	tid: <уникальный идентификатор задачи>
	o: {
		id: <INT> //ID - уникальный цифровой идентификатор источника
		dt: {
			s: <INT> //dateTimeStart — начальное дата и время в unixtime (то есть количество секунд с начала эпохи Unix)
			e: <INT> //dateTimeEnd
		}
		p: <STRINT> //protocol — протокол транспортного уровня, 'tcp', 'udp', или 'any', 'any' можно не писать, пустое значение будет так же восприниматься как 'any'		
		f: { //filters — параметры фильтрации, внутри УСЛОВИЕ «И»
			ip: { // IP адрес
				any: [<STRING> «ИЛИ» <STRING>] // ip адреса в виде строки
				УСЛОВИЕ «ИЛИ»
				src: [<STRING>, <STRING>]
				УСЛОВИЕ «И»
				dst: [<STRING>]			
			} // между 'any' и 'src' и 'dst' УСЛОВИЕ «ИЛИ», между 'src' и 'dst' УСЛОВИЕ «И»
			pt: { // Порты 
				any: [<STRING> «ИЛИ» <STRING>]
				УСЛОВИЕ «ИЛИ»
				src: [<STRING>, <STRING>]
				УСЛОВИЕ «И»
				dst: [<STRING>]			
			},
			nw: { //подсети
				any: [<STRIN/STRING> «ИЛИ» <STRIN/STRING>]
				УСЛОВИЕ «ИЛИ»
				src: [<STRIN/STRING>, <STRIN/STRING>]
				УСЛОВИЕ «И»
				dst: [<STRIN/STRING>]
			}
	ПРИМЕР: { 
			ip: {
				any: ['192.168.156.12', '45.78.9.10'],
				src: [],
				dst: ['10.34.24.5', '8.67.3.2']
			},
			pt: {
				any: [],
				src: ['16789', '17584'],
				dst: ['80', '8080']
			},
			nw: {
				any: ['45.23.100.23/25'],
				src: [],
				dst: []
			}
		} 
		}
	}
}

	После валидации параметров фильтрации, проверки наличия источника с заданным ID и проверки состояния данного источника клиенту API будет отправлено информационное сообщение соответствующего содержание и отклонена или запущена задача по фильтрации сетевого трафика.
	В результате выполнения процесса фильтрации клиенту API, инициализировавшему задачу, будут приходить информационные сообщения об изменении статуса задачи по фильтрации или параметров фильтрации. Пример сообщения:
{
	t: 'information',
	s: 'filtration control',	
	i: 'task processing',
	tid: <уникальный идентификатор задачи>
	o: {
		id: <INT> //ID - уникальный цифровой идентификатор источника
		tidapp: <STRING> //TaskIDApp - уникальный цифровой идентификатор задачи присвоенный приложением
		s: <STRING> //Status - статус задачи 'wait'/'refused'/'execute'/'complete'/'stop' ('ожидает' / 'отклонена' / 'выполняется' / 'завершена' / 'остановлена')
		nfmfp: <INT> //NumberFilesMeetFilterParameters — кол-во файлов удовлетворяющих параметрам фильтрации
		npf: <INT> //NumberProcessedFiles — кол-во обработанных файлов
		nffrf: <INT> //NumberFilesFoundResultFiltering — кол-во файлов найденных в результате выполнения фильтрации
		nepf: <INT> //NumberErrorProcessedFiles — кол-во не обработанных файлов или файлов обработанных с ошибкой
		ndf: <INT> //NumberDirectoryFiltration — кол-во директорий по которым выполняется фильтрация
		sfmfp: <INT> //SizeFilesMeetFilterParameters — общий размер файлов (в байтах), удовлетворяющих параметрам фильтрации
		sffrf: <INT> //SizeFilesFoundResultFiltering — общий размер файлов (в байтах), найденных в результате фильтрации
		pss: <STRING> //PathStoregeSource - путь до директории находящейся на источнике в которой сохраняются результаты при выполнении фильтрации
		ffi: { //FoundFilesInformation — информация о файлах, ключом является имя файла 
			<имя_файла>: {
				s: <INT> //Size — размер файла
				h: <STRING> //Hex — хеш файла			
			}
		} //Данный параметр заполняется только если статус задачи равен 'execute', для получения полного списка файлов нужно сформировать отдельный запрос где 's' равно 'information search control'
	}
} 

	Задача по фильтрации сетевого трафика может быть отменена или остановлена клиентом API. После отмены или останова задачи возобновление данной задачи не возможно. Отменить или остановить задачу может только клиент API инициировавший данную задачу.  Пример запроса на останов задачи по фильтрации сетевого трафика:
{
	t: 'command',
	s: 'filtration control', 
	i: 'to cancel filtering',
	tid: <уникальный идентификатор задачи>
	o: {}
}

3. Управление передачей файлов.
	
	Задача по скачиванию файлов может быть связана как с одним так и с несколькими   источниками, при этом, на одном источнике, одновременно может выполнятся только одна задача по скачиванию. При добавление нескольких задач по скачиванию файлов с одного и того же источника, начинает выполняется задача, добавленная первой, а все последующие добавленные задачи ставятся в очередь. При добавлении задачи в очередь на скачивание файлов осуществляется проверка наличия ожидающей или уже выполняемой задачи по её ID. Если задача с таким ID существует то в список задач она не добавляется, а клиент API получает ответ со статусом «отклонена» и информационное сообщение в котором описываются причины отклонения задачи.    
	Задача может быть инициализирована как в ручном режиме, действиями пользователя через клиента API, так и в автоматическом режиме, по мере завершения процесса фильтрации сетевого трафика, но только, при условии что общий объем найденных в результате фильтрации файлов не превышает значения «maximumTotalSizeFilesDownloadedAutomatically» заданного в конфигурационном файле. Если задача инициализируется в автоматическом режиме, то она также ставится в очередь если на источнике уже выполняется задача по скачиванию файлов. 
	При запуске задачи в ручном режиме, пользователь может запустить задачу, как для всего списка файлов, так и для выбранного им перечня файлов, передав их серверу API в виде массива.
	Полученные файлы сохраняются в долговременном хранилище, на локальных дисках сервера, по пути, сформированному иерархией директорий, состоящих из директории  указанной в конфигурационном файле приложения, в разделе «directoryLongTermStorageDownloadedFiles», директории из уникального числового идентификатора источника (ID) его краткого названия и иерархии директорий состоящих из года, месяца, числа начального значения интервала времени фильтрации. Название директории в которой непосредственно размещаются скаченные файлы формируется по шаблону <начальное_дата_и_время_события>_<конечное_дата_и_время_события>_
<идентификатор_задачи_сформированный_приложением>. Пример пути директории для долговременного хранения скачанных файлов: «/__STORAGE/ISEMS-NIH_MASTER/1002-Sensor_RSNet/2019/07/23/23.07.2019_0:24_23.07.2019_23:55_454b4ae767f6dfa35c9f0570526d3c5b». 
	При инициализации выполнения задачи как в ручном так и в автоматическом режиме, различные информационные сообщения (начало, ход выполнения, окончание) получает только тот клиент API, который ранее инициализировал задачу по фильтрации сетевого трафика.
	Пример запроса, от клиента API, на выполнение задачи по скачиванию файлов в ручном режиме:
{
	t: 'command',
	s: 'download control', 
	i: 'to start downloading',
	tid: <уникальный идентификатор задачи клиента>
	o: {
		id: <INT> //SourceID — уникальный идентификатор источника
		tidapp: <STRING> //TaskIDApp — уникальный идентификатор задачи по фильтрации полученный от API-сервера в результате выполнения задачи по фильтрации
		fl: [<STRING>, <STRING>] //FileList — список имен файлов в виде массива (если массив пуст то считается что будут скачиваться все файлы которые были найдены в результате фильтрации)
	}
}
	Пример ответа, от сервера API с информацией о ходе выполнения задачи по скачиванию файлов:
{
	t: 'information',
	s: 'download control', 
	i: 'task processing',
	tid: <уникальный идентификатор задачи клиента>
	o: {
		id: <INT> //ID - уникальный цифровой идентификатор источника
		tidapp: <STRING> //TaskIDApp — уникальный идентификатор задачи по фильтрации присвоенный API-сервером в результате выполнения задачи по фильтрации
		s: <STRING> //Status - статус задачи 'wait'/'refused'/'execute'/'complete'/'stop' ('ожидает' / 'отклонена' / 'выполняется' / 'завершена' / 'остановлена')
		nft: <INT> //NumberFilesTotal — общее количество скачиваемых файлов
		nfd: <INT> //NumberFilesDownloaded — количество успешно скаченных файлов
		nfde: <INT> //NumberFilesDownloadedError — количество файлов скаченных с ошибкой
		pdsdf: <STRING> //PathDirectoryStorageDownloadedFiles — путь до директории в файловом хранилище
		dfi: { //DetailedFileInformation — подробная информация о скачиваемом файле
			n: <STRING> //Name — название файла
			h: <STRING> //Hex — хеш сумма
			fsb: <INT> //FullSizeByte — полный размер файла в байтах
			asb: <INT> //AcceptedSizeByte — скаченный размер файла в байтах
			asp: <INT> //AcceptedSizePercent — скаченный размер файла в процентах
		}
	}
}
	Пример запроса, от клиента API, на останов задачи по скачиванию файлов:
{
	t: 'command',
	s: 'download control', 
	i: 'to cancel downloading',
	tid: <уникальный идентификатор задачи клиента>
	o: {
		id: <INT> //ID - уникальный цифровой идентификатор источника
		tidapp: <STRING> //TaskIDApp — уникальный идентификатор задачи полученный от API-сервера в результате выполнения задачи по фильтрации	
	}
}

	При успешном скачивании файла, когда контрольная сумма скаченного на локальное хранилище файла совпадает с контрольной суммой файла, расположенного на источнике, файл находящийся на источнике автоматически удаляется. В результате после скачивания всех файлов с источника, на нем останется только директория, содержащая файл «README.xml» с информацией о ранее выполненной задаче по фильтрации. 